{"version":3,"sources":["utils/_colors.scss","utils/_mixins.scss","utils/_utils.scss","utils/_fonts.scss","utils/_constants.scss","../../../../source/node_modules/foundation-sites/scss/components/_visibility.scss","../../../../source/node_modules/foundation-sites/scss/util/_breakpoint.scss","../../../../source/node_modules/foundation-sites/scss/util/_mixins.scss","base/_base.scss"],"names":[],"mappings":"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","file":"app.css","sourcesContent":["\n/// @example\n///   .element {\n///     color: palette(ui, 'brand');\n///\n\n$palettes: (\n  brand: (\n    'yuma':            #d0cc96\n  ),\n  ui: (\n    'black':           #0b0b0b,\n    'white':           #fff,\n    'alabaster':       #fbfbfb,\n    'sand':            #f5f5f5,\n    'alto':            #d0d0d0,\n    'chalice':         #adadad,\n    'boulder':         #767676,\n    'tundora':         #3a3b3a\n  )\n);\n\n\n\n\n/// Function to parse color palettes\n@function palette($palette, $tone: 'brand') {\n  @return map-get(map-get($palettes, $palette), $tone);\n}\n\n\n\n\n/// Generating color and background Classes\n/// from color map\n$color-theme-list: (\n  yuma: brand,\n  black: ui,\n  white: ui,\n  alabaster: ui,\n  alto: ui\n) !default;\n\n\n\n\n/// Classes to use in templates\n@mixin color-theme($color, $section) {\n  .color--#{$color} {\n    color: palette($section, #{$color});\n  }\n\n  .background--#{$color} {\n    background-color: palette($section, #{$color});\n  }\n}\n\n@each $key, $value in $color-theme-list {\n  @include color-theme($key, $value);\n}\n","// Utility mixins\n\n\n\n\n// Using margins and paddings based on $global-baseline\n// to ensure vertical and horizontal grid\n@mixin u-baseline($size: 1, $type: margin) {\n  $baseline: #{$global-baseline * ($size / 16)}rem;\n\n  #{$type}: $baseline;\n}\n\n\n\n\n// helper to calculate line-height based\n// on baseline grid\n//\n// IMPORTANT: only used in _fonts.scss\n// DO NOT USE this mixins in your CSS!\n// USE font() instead.\n@mixin u-font-baseline($size, $lineheight) {\n  font-size: rem-calc($size);\n  line-height: $lineheight / $size;\n}\n\n\n\n\n\n\n\n\n\n\n// Helper to pull image outside of GRID\n@mixin u-img-pull($value) {\n  margin-left: -($value);\n  margin-right: -($value);\n  width: calc(100% + #{$value * 2});\n  max-width: calc(100% + #{$value * 2});\n}\n\n\n\n\n\n\n\n\n\n// helper for preview images\n// @source: http://andyshora.com/css-image-container-padding-hack.html\n@mixin u-img-preview($view: square) {\n  background-color: palette(ui, 'alto');\n  display: block;\n  position: relative;\n  overflow: hidden;\n\n  img {\n    @include u-img-responsive;\n\n    &.thumb {\n      // display: none;\n      filter: blur(20px);\n      top: 0;\n      right: 0;\n      bottom: 0;\n      left: 0;\n      width: 100%;\n      position: absolute;\n      z-index: 0;\n    }\n\n    &.original {\n      position: absolute;\n      top: 0;\n      left: 0;\n    }\n  }\n}\n\n\n\n\n\n// Text link with borders\n//\n//\n@mixin u-link-border($type: null) {\n  // Show border on hover\n  @if $type == hover {\n    border-bottom: rem-calc(2) solid transparent;\n\n    @include breakpoint(large) {\n      border-width: rem-calc(3);\n    }\n\n    &:hover,\n    &:active {\n      border-color: palette(brand, 'yuma');\n    }\n\n  // Show border permanently\n  } @elseif $type == static {\n    border-bottom: rem-calc(2) solid palette(brand, 'yuma');\n    font-weight: bold;\n\n    @include breakpoint(large) {\n      border-width: rem-calc(3);\n    }\n\n  // Show border initially with hover\n  } @elseif $type == active {\n    border-bottom: rem-calc(3) solid palette(brand, 'yuma');\n\n    @include breakpoint(large) {\n      border-width: rem-calc(3);\n    }\n\n    &:hover,\n    &:active {\n      border-color: transparent;\n    }\n\n  // Default underline\n  } @else {\n    font-weight: bold;\n    text-decoration: underline;\n\n    &:hover,\n    &:active {\n      text-decoration-color: palette(brand, 'yuma');\n    }\n  }\n}\n\n\n\n// Icon as link\n@mixin u-icon-link() {\n  .c-icon {\n    transition: $global-transition;\n    transform-origin: 50% 100%;\n  }\n\n  a:hover {\n    .c-icon {\n      transform: scale(1.1);\n    }\n  }\n}\n\n\n\n\n\n\n\n// Links for content mixin\n@mixin u-content-links() {\n  a:not(img) {\n    @include u-link-border;\n  }\n}\n\n\n\n\n\n// List formatting\n@mixin u-list($type: ol) {\n  $breakpoint: large;\n  $offset: rem-calc($global-baseline * 3.5);\n  $color: palette(brand, 'yuma');\n\n  @include u-baseline(3, margin-bottom);\n\n  @include breakpoint($breakpoint) {\n    @include u-baseline(4, margin-bottom);\n  }\n\n  > li {\n    @include u-baseline(1, margin-bottom);\n    list-style-type: none;\n    position: relative;\n\n    @include breakpoint($breakpoint) {\n      @include u-baseline(2, margin-bottom);\n    }\n\n    &:after {\n      position: absolute;\n      left: -($offset);\n    }\n\n    @if $type == ol {\n      counter-increment: list; // create counter type\n\n      &:after {\n        @include font($font-options-m-secondary);\n        font-weight: bold;\n        font-style: italic;\n        color: $color;\n        content: counter(list) '.';\n        position: absolute;\n        left: -($offset * 1.5);\n        text-align: right;\n        top: 0;\n        width: rem-calc(30);\n\n        @include breakpoint($breakpoint) {\n          @include font($font-options-xl-secondary);\n        }\n      }\n    }\n\n    @if $type == ul {\n      &:after {\n        @include u-baseline(1.5, top);\n        background: $color;\n        content: '';\n        width: .5rem;\n        height: .5rem;\n        display: inline-block;\n\n        @include breakpoint($breakpoint) {\n\n        }\n      }\n    }\n  }\n}\n\n\n\n\n// Content formatting\n//\n//\n@mixin u-content-formatting() {\n  @include u-content-links;\n\n  @include font($font-base-s);\n\n  @include breakpoint(medium) {\n    @include font($font-base-l);\n  }\n\n  @include breakpoint(large) {\n    @include font($font-base-ll);\n  }\n\n  a {\n    @include u-content-links;\n  }\n\n  > p {\n    @include u-baseline(3, margin-bottom);\n    margin-top: 0;\n    word-break: break-word;\n\n    @include breakpoint(large) {\n      @include u-baseline(4, margin-bottom);\n      margin-top: 0;\n    }\n  }\n\n  h2,\n  h3,\n  h4 {\n    @include font($font-base-l-narrow);\n    margin-top: 0;\n\n    @include breakpoint(large) {\n      @include font($font-base-ll);\n    }\n\n    &:not(:first-of-type) {\n      margin-top: 0;\n    }\n  }\n\n  ul {\n    @include u-list(ul);\n    @include u-baseline(8, padding-left);\n  }\n\n  ol {\n    @include u-list(ol);\n    @include u-baseline(8, padding-left);\n  }\n}\n\n@mixin u-content-formatting-fonts() {\n  @include font-replace(copy);\n\n  h2,\n  h3,\n  h4 {\n    @include font-replace(display);\n  }\n}\n\n\n\n\n// Placeholder styles\n@mixin u-input-placeholder() {\n  font-weight: normal;\n  font-style: italic;\n}\n\n\n\n\n\n\n\n\n\n// helper for smooth transitioned\n// visibility toggles\n@mixin u-toggle-visibility($mode: 'hide', $zindex: 1) {\n  @if $mode == 'hide' {\n    opacity: 0;\n    visibility: hidden;\n    z-index: -1;\n  }\n\n  @if $mode == 'show' {\n    opacity: 1;\n    visibility: visible;\n    z-index: $zindex;\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n// setting images to responsive width\n// and fluid behaviour\n@mixin u-img-responsive() {\n  display: block;\n  max-width: 100%;\n  max-height: 100%;\n  height: auto;\n  width: 100%;\n}\n\n\n\n\n\n\n\n\n// removing list styles and box\n@mixin u-list-reset() {\n  list-style: none;\n  margin-left: 0;\n  padding-left: 0;\n}\n\n\n\n\n\n\n\n\n// adding ellipsis to element\n//\n// @param {Number} $max-width â€“ required|fallback\n@mixin u-ellipsis($max-width: 200) {\n  max-width: rem-calc($max-width);\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Product image hover\n@mixin u-img-hover() {\n  img {\n    transition: $global-transition;\n  }\n\n  &:hover,\n  &:active {\n    img {\n      filter: brightness(110%);\n    }\n  }\n}\n\n\n\n\n\n\n\n\n\n// a11y-friendly hidden elements\n@mixin u-a11y-hidden() {\n  position: absolute;\n  width: rem-calc(1);\n  height: rem-calc(1);\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  clip-path: inset(50%);\n}\n\n\n@mixin u-a11y-visible() {\n  clip: auto;\n  width: auto;\n  height: auto;\n  overflow: auto;\n}\n\n\n\n\n\n\n\n\n\n\n// Vendor prefixed keyframes\n@mixin keyframes($animationName) {\n  @-webkit-keyframes #{$animationName} {\n    @content;\n  }\n\n  @-moz-keyframes #{$animationName} {\n    @content;\n  }\n\n  @-o-keyframes #{$animationName} {\n    @content;\n  }\n\n  @keyframes #{$animationName} {\n    @content;\n  }\n}\n","// Misc. helper classes\n// to use in HTML markup\n\n\n\n// Responsive image\n//\n// (max-width and width: 100%)\n.u-img-responsive {\n  @include u-img-responsive;\n}\n\n\n\n.u-img-preview {\n  @include u-img-preview;\n}\n\n\n\n// Centered images with defined width\n// on HTML image tag\n.u-img-center {\n  img {\n    display: block;\n    margin: 0 auto;\n  }\n}\n\n\n\n.u-img--fullwidth {\n  display: block;\n  max-width: 100%;\n  width: 100%;\n}\n\n\n\n// Centered contents\n.u-center,\n.u-text--center {\n  text-align: center !important;\n}\n\n\n\n\n// Removing text-transforms from fonts\n.u-text--normal {\n  text-transform: none;\n}\n\n.u-text--right {\n  text-align: right !important;\n}\n\n\n// Adding uppercase to fonts\n.u-text--uppercase {\n  text-transform: uppercase;\n}\n\n\n\n\n// Line-through\n.u-linethrough {\n  text-decoration: line-through;\n}\n\n\n\n\n// Resetting display font from font\n// for footnotes (*) etc.\n.u-footnote {\n  font-family: font(base, 'body');\n}\n\n\n\n\n// Disabling pointer-events from maps\n.u-maps {\n  width: 100%;\n\n  &.scrolloff {\n    pointer-events: none;\n  }\n}\n\n\n\n\n// Adding global transition to element\n.u-transition {\n  transition: $global-transition;\n}\n\n\n\n// Element is hidden\n.u-hidden {\n  display: none;\n}\n","/// Web fonts\n\n// @font-face {\n//   font-family: 'SpilloutSans';\n//   src: url('/assets/fonts/sans-regular.woff2') format('woff2'), url('../fonts/sans-light.woff') format('woff');\n//   font-weight: normal;\n// }\n\n\n\n\n/// Font settings\n$font-stack: ('Arial', 'Helvetica', sans-serif);\n\n$fonts: (\n  base: (\n    'preload':        (sans-serif),\n    'base':           (sans-serif),\n    'stack':          $font-stack,\n    'body':           ('Webfont', #{$font-stack}),\n    'copy':           ('Webfont', #{$font-stack}),\n    'display':        ('Webfont', #{$font-stack}),\n    'size':           100%,\n    'line-height':    1.5\n  ),\n  size: (\n    'xxxs':           10,\n    'xxs':            12,\n    'xs':             14,\n    's':              15,\n    'm':              16,\n    'l':              18,\n    'll':             21,\n    'xl':             22,\n    'xll':            24,\n    'xxl':            32,\n    'xxll':           40,\n    'xxxl':           56,\n    'xxxxl':          64,\n    'xxxxxxl':        96,\n    'xxxxxxxl':       196\n  )\n);\n\n\n\n\n/// Function to parse font map\n@function font($font, $type: 'base') {\n  @return map-get(map-get($fonts, $font), $type);\n}\n\n\n$font-base-s: (\n  size:          's',\n  line-height:   24,\n  family:        'base'\n);\n\n\n\n\n// Mixin to generate font sizes and baseline metrics\n//\n// @example:\n//   .module {\n//     @include font($font-options-s);\n//   }\n$options: (\n  size:          m,\n  line-height:   24,\n  family:        'copy'\n);\n\n@mixin font($options) {\n  $size: font(size, map-get($options, size));\n\n  @include u-font-baseline($size, map-get($options, line-height));\n  font-family: font(base, map-get($options, family));\n}\n\n// Replace basic font with loaded webfont\n@mixin font-replace($family) {\n  font-family: font(base, $family);\n}\n","@import 'colors';\n@import 'fonts';\n\n\n// _foundation-settings.scss\n$global-body-background: palette(ui, 'alabaster');\n$global-body-color: palette(ui, 'black');\n\n\n\n\n// Fonts\n$global-font-family: font(base, 'body');\n$global-font-heading: font(base, 'display');\n$global-link-color: palette(ui, 'black');\n$global-accent-color: palette(brand, 'yuma');\n\n\n\n\n// Grid\n$global-grid-gutter: .75rem;\n$global-max-width: 1140px;\n$global-grid-large: 1400px;\n$global-grid-xlarge: 1700px;\n$global-gutter: 24px;\n$global-content-col-medium: 8;\n$global-content-col-large: 6;\n\n$global-outside-gutter-small: .625rem;\n$global-outside-gutter: .9375rem;\n\n\n\n// Baseline\n//\n// DO NOT CHANGE THIS UNLESS YOU\n// KNOW WHAT YOU'RE DOING\n$global-baseline: 8;\n\n\n\n\n// Transitions\n$global-easeInOutExpo: cubic-bezier(1, 0, 0, 1);\n$global-easing: ease-in-out;\n$global-easing-duration: .15s;\n$global-transition: all $global-easing-duration $global-easing;\n$global-transition-smooth: all .25s $global-easing;\n$global-svg-transform-transition: transform $global-easing-duration $global-easing;\n\n\n\n\n// Shadows\n$global-shadow: 0 0 4px rgba(0, 0, 0, .25);\n\n\n\n\n// Letter spacing\n$global-letterspacing-small: .56;\n$global-letterspacing-medium: 1.56;\n\n\n\n\n// Border\n$global-border-width: 3px;\n$global-border: $global-border-width solid palette(ui, 'black');\n\n\n\n// Input and button size\n$global-controls-height: ($global-baseline * 5);\n$global-controls-height-large: ($global-baseline * 6);\n$global-controls-background: palette(ui, 'white');\n\n\n\n\n// Navigation\n$global-navigation-breakpoint: xlarge;\n$global-navigation-breakpoint-down: large down;\n$global-navigation-mobile-width: 265px;\n\n\n\n\n// Footer\n$global-footer-breakpoint: medium;\n","// Foundation for Sites by ZURB\n// foundation.zurb.com\n// Licensed under MIT Open Source\n\n/// Hide an element by default, only displaying it above a certain screen size.\n/// @param {Keyword} $size - Breakpoint to use. **Must be a breakpoint defined in `$breakpoints`.**\n@mixin show-for($size) {\n  $size: map-get($breakpoints, $size);\n  $size: -zf-bp-to-em($size) - (1 / 16);\n\n  @include breakpoint($size down) {\n    display: none !important;\n  }\n}\n\n/// Hide an element by default, only displaying it within a certain breakpoint.\n/// @param {Keyword} $size - Breakpoint to use. **Must be a breakpoint defined in `$breakpoints`.**\n@mixin show-for-only($size) {\n  $lower-bound-size: map-get($breakpoints, $size);\n  $upper-bound-size: -zf-map-next($breakpoints, $size);\n\n  // more often than not this will be correct, just one time round the loop it won't so set in scope here\n  $lower-bound: -zf-bp-to-em($lower-bound-size) - (1 / 16);\n  // test actual lower-bound-size, if 0 set it to 0em\n  @if strip-unit($lower-bound-size) == 0 {\n    $lower-bound: -zf-bp-to-em($lower-bound-size);\n  }\n\n  @if $upper-bound-size == null {\n    @media screen and (max-width: $lower-bound) {\n      display: none !important;\n    }\n  }\n  @else {\n    $upper-bound: -zf-bp-to-em($upper-bound-size);\n\n    @media screen and (max-width: $lower-bound), screen and (min-width: $upper-bound) {\n      display: none !important;\n    }\n  }\n}\n\n\n/// Show an element by default, and hide it above a certain screen size.\n/// @param {Keyword} $size - Breakpoint to use. **Must be a breakpoint defined in `$breakpoints`.**\n@mixin hide-for($size) {\n  @include breakpoint($size) {\n    display: none !important;\n  }\n}\n\n/// Show an element by default, and hide it above a certain screen size.\n/// @param {Keyword} $size - Breakpoint to use. **Must be a breakpoint defined in `$breakpoints`.**\n@mixin hide-for-only($size) {\n  @include breakpoint($size only) {\n    display: none !important;\n  }\n}\n\n@mixin foundation-visibility-classes {\n  // Basic hiding classes\n  .hide {\n    display: none !important;\n  }\n\n  .invisible {\n    visibility: hidden;\n  }\n\n  // Responsive visibility classes\n  @each $size in $breakpoint-classes {\n    @if $size != $-zf-zero-breakpoint {\n      .hide-for-#{$size} {\n        @include hide-for($size);\n      }\n\n      .show-for-#{$size} {\n        @include show-for($size);\n      }\n    }\n\n    .hide-for-#{$size}-only {\n      @include hide-for-only($size);\n    }\n\n    .show-for-#{$size}-only {\n      @include show-for-only($size);\n    }\n  }\n\n  // Screen reader visibility classes\n  // Need a \"hide-for-sr\" class? Add aria-hidden='true' to the element\n  .show-for-sr,\n  .show-on-focus {\n    @include element-invisible;\n  }\n\n  // Only display the element when it's focused\n  .show-on-focus {\n    &:active,\n    &:focus {\n      @include element-invisible-off;\n    }\n  }\n\n  // Landscape and portrait visibility\n  .show-for-landscape,\n  .hide-for-portrait {\n    display: block !important;\n\n    @include breakpoint(landscape) {\n      display: block !important;\n    }\n\n    @include breakpoint(portrait) {\n      display: none !important;\n    }\n  }\n\n  .hide-for-landscape,\n  .show-for-portrait {\n    display: none !important;\n\n    @include breakpoint(landscape) {\n      display: none !important;\n    }\n\n    @include breakpoint(portrait) {\n      display: block !important;\n    }\n  }\n}\n","// Foundation for Sites by ZURB\n// foundation.zurb.com\n// Licensed under MIT Open Source\n\n////\n/// @group breakpoints\n////\n\n/// A list of named breakpoints. You can use these with the `breakpoint()` mixin to quickly create media queries.\n/// @type Map\n$breakpoints: (\n  small: 0,\n  medium: 640px,\n  large: 1024px,\n  xlarge: 1200px,\n  xxlarge: 1440px,\n) !default;\n\n/// The largest named breakpoint in which to include print as a media type\n/// @type Keyword\n$print-breakpoint: large !default;\n\n$-zf-zero-breakpoint: small !default;\n\n$-zf-breakpoints-keys: map-to-list($breakpoints, 'keys');\n\n@if nth(map-values($breakpoints), 1) != 0 {\n  @error 'Your smallest breakpoint (defined in $breakpoints) must be set to \"0\".';\n}\n@else {\n  $-zf-zero-breakpoint: nth(map-keys($breakpoints), 1);\n}\n\n/// All of the names in this list will be output as classes in your CSS, like `.small-12`, `.medium-6`, and so on. Each value in this list must also be in the `$breakpoints` map.\n/// @type List\n$breakpoint-classes: (small medium large) !default;\n\n/// Generates a media query string matching the input value. Refer to the documentation for the `breakpoint()` mixin to see what the possible inputs are.\n///\n/// @param {Keyword|Number} $val [small] - Breakpoint name, or px, rem, or em value to process.\n@function breakpoint($val: $-zf-zero-breakpoint) {\n  // Size or keyword\n  $bp: nth($val, 1);\n  // Value for max-width media queries\n  $bp-max: 0;\n  // Direction of media query (up, down, or only)\n  $dir: if(length($val) > 1, nth($val, 2), up);\n  // Eventual output\n  $str: '';\n  // Is it a named media query?\n  $named: false;\n\n  // Orientation media queries have a unique syntax\n  @if $bp == 'landscape' or $bp == 'portrait' {\n    @return '(orientation: #{$bp})';\n  }\n  @else if $bp == 'retina' {\n    @return '(-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi)';\n  }\n\n  // Try to pull a named breakpoint out of the $breakpoints map\n  @if type-of($bp) == 'string' {\n    @if map-has-key($breakpoints, $bp) {\n      @if $dir == 'only' or $dir == 'down' {\n        $bp-max: -zf-map-next($breakpoints, $bp);\n      }\n\n      $bp: map-get($breakpoints, $bp);\n      $named: true;\n    }\n    @else {\n      $bp: 0;\n      @warn 'breakpoint(): \"#{$val}\" is not defined in your $breakpoints setting.';\n    }\n  }\n\n  // Convert any pixel, rem, or unitless value to em\n  $bp: -zf-bp-to-em($bp);\n  @if $bp-max {\n    $bp-max: -zf-bp-to-em($bp-max) - (1/16);\n  }\n\n  // Conditions to skip media query creation\n  // - It's a named breakpoint that resolved to \"0 down\" or \"0 up\"\n  // - It's a numeric breakpoint that resolved to \"0 \" + anything\n  @if $bp > 0em or $dir == 'only' or $dir == 'down' {\n    // `only` ranges use the format `(min-width: n) and (max-width: n)`\n    @if $dir == 'only' {\n      // Only named media queries can have an \"only\" range\n      @if $named == true {\n        // Only use \"min-width\" if the floor is greater than 0\n        @if $bp > 0em {\n          $str: $str + '(min-width: #{$bp})';\n\n          // Only add \"and\" to the media query if there's a ceiling\n          @if $bp-max != null {\n            $str: $str + ' and ';\n          }\n        }\n\n        // Only use \"max-width\" if there's a ceiling\n        @if $bp-max != null {\n          $str: $str + '(max-width: #{$bp-max})';\n        }\n      }\n      @else {\n        @warn 'breakpoint(): Only named media queries can have an `only` range.';\n      }\n    }\n\n    // `down` ranges use the format `(max-width: n)`\n    @else if $dir == 'down' {\n      $max: if($named, $bp-max, $bp);\n\n      // Skip media query creation if input value is exactly \"0 down\",\n      // unless the function was called as \"small down\", in which case it's just \"small only\"\n      @if $named or $bp > 0em {\n        @if $max != null {\n          $str: $str + '(max-width: #{$max})';\n        }\n      }\n    }\n\n    // `up` ranges use the format `(min-width: n)`\n    @else if $bp > 0em {\n      $str: $str + '(min-width: #{$bp})';\n    }\n  }\n\n  @return $str;\n}\n\n/// Wraps a media query around the content you put inside the mixin. This mixin accepts a number of values:\n///  - If a string is passed, the mixin will look for it in the `$breakpoints` map, and use a media query there.\n///  - If a pixel value is passed, it will be converted to an em value using `$global-font-size` as the base.\n///  - If a rem value is passed, the unit will be changed to em.\n///  - If an em value is passed, the value will be used as-is.\n///\n/// @param {Keyword|Number} $value - Breakpoint name, or px, rem, or em value to process.\n///\n/// @output If the breakpoint is \"0px and larger\", outputs the content as-is. Otherwise, outputs the content wrapped in a media query.\n@mixin breakpoint($value) {\n  $str: breakpoint($value);\n  $bp: index($-zf-breakpoints-keys, $value);\n  $pbp: index($-zf-breakpoints-keys, $print-breakpoint);\n\n  $old-zf-size: null;\n\n  // Make breakpoint size available as a variable\n  @if global-variable-exists(-zf-size) {\n    $old-zf-size: $-zf-size;\n  }\n  $-zf-size: nth($value, 1) !global; // get the first value to account for `only` and `down` keywords\n\n  // If $str is still an empty string, no media query is needed\n  @if $str == '' {\n    @content;\n  }\n\n  // Otherwise, wrap the content in a media query\n  @else {\n    // For named breakpoints less than or equal to $print-breakpoint, add print to the media types\n    @if $bp != null and $bp <= $pbp {\n      @media print, screen and #{$str} {\n        @content;\n       }\n    }\n    @else {\n      @media screen and #{$str} {\n        @content;\n      }\n    }\n  }\n\n  @if $old-zf-size != null {\n    // Restore the old breakpoint size\n    $-zf-size: $old-zf-size !global;\n  } @else {\n    $-zf-size: null !global;\n  }\n}\n\n/// Convers the breakpoints map to a URL-encoded string, like this: `key1=value1&key2=value2`. The value is then dropped into the CSS for a special `<meta>` tag, which is read by the Foundation JavaScript. This is how we transfer values from Sass to JavaScript, so they can be defined in one place.\n/// @access private\n///\n/// @param {Map} $map - Map to convert.\n///\n/// @returns {String} A string containing the map's contents.\n@function -zf-bp-serialize($map) {\n  $str: '';\n  @each $key, $value in $map {\n    $str: $str + $key + '=' + -zf-bp-to-em($value) + '&';\n  }\n  $str: str-slice($str, 1, -2);\n\n  @return $str;\n}\n\n/// Find the next key in a map.\n/// @access private\n///\n/// @param {Map} $map - Map to traverse.\n/// @param {Mixed} $key - Key to use as a starting point.\n///\n/// @returns {Mixed} The value for the key after `$key`, if `$key` was found. If `$key` was not found, or `$key` was the last value in the map, returns `null`.\n@function -zf-map-next($map, $key) {\n\n  // Store the keys of the map as a list\n  $values: map-keys($map);\n\n  $i: 0;\n\n  // If the Key Exists, Get the index of the key within the map and add 1 to it for the next breakpoint in the map\n  @if (map-has-key($map, $key)) {\n    $i: index($values, $key) + 1;\n  }\n\n  // If the key doesn't exist, or it's the last key in the map, return null\n  @if ($i > length($map) or $i == 0) {\n    @return null;\n  }\n  // Otherwise, return the value\n  @else {\n    @return map-get($map, nth($values, $i));\n  }\n\n}\n\n/// Return a list of our named breakpoints less than $key. Useful for dealing with\n/// responsive gutters for the grid.\n/// @access private\n///\n/// @param {String} $key - Key to use as last breakpoint.\n///\n/// @returns {Array} The list of breakpoints up to and. If $key is auto, returns breakpoints above the zero\n@function -zf-breakpoints-less-than($key) {\n  $list: ();\n  $found_key: false;\n\n  @each $name in $-zf-breakpoints-keys {\n    @if ($name == $key) {\n      $found_key: true;\n    }\n    @if not $found_key {\n      $list: append($list, $name);\n    }\n  }\n  @return $list;\n}\n\n/// Return a list of our named breakpoints less than $key. Useful for dealing with\n/// responsive gutters for the grid.\n/// @access private\n///\n/// @param {String} $breakpoing - a named or non-named breakpoing.\n///\n/// @returns {Array} The list of breakpoints up to and. If $key is auto, returns breakpoints above the zero\n@function -zf-closest-named-breakpoint($breakpoint) {\n  $last: $-zf-zero-breakpoint;\n  $found: false;\n\n  $value: unitless-calc($breakpoint, 1px);\n  @each $key, $val in $breakpoints {\n    @if not $found {\n      @if unitless-calc($val) > $value {\n        $found: true;\n      } @else {\n        $last: $key;\n      }\n    }\n  }\n\n  @return $last;\n}\n\n/// Get a value for a breakpoint from a responsive config map or single value.\n/// - If the config is a single value, return it regardless of `$value`.\n/// - If the config is a map and has the key `$value`, the exact breakpoint value is returned.\n/// - If the config is a map and does *not* have the breakpoint, the value matching the next lowest breakpoint in the config map is returned.\n/// @access private\n///\n/// @param {Number|Map} $map - Responsive config map or single value.\n/// @param {Keyword} $value - Breakpoint name to use.\n///\n/// @return {Mixed} The corresponding breakpoint value.\n@function -zf-get-bp-val($map, $value) {\n  // If the given map is a single value, return it\n  @if type-of($map) == 'number' {\n    @return $map;\n  }\n\n\n  // Check if the breakpoint name exists globally\n  @if not map-has-key($breakpoints, $value) {\n    @if type-of($value) == 'number' {\n      $value: -zf-closest-named-breakpoint($value);\n    } @else {\n      @return null;\n    }\n  }\n  // Check if the breakpoint name exists in the local config map\n  @else if map-has-key($map, $value) {\n    // If it does, just return the value\n    @return map-get($map, $value);\n  }\n  // Otherwise, find the next lowest breakpoint and return that value\n  @else {\n    $anchor: null;\n    $found: false;\n\n    @each $key, $val in $breakpoints {\n      @if not $found {\n        @if map-has-key($map, $key) {\n          $anchor: $key;\n        }\n        @if $key == $value {\n          $found: true;\n        }\n      }\n    }\n\n    @return map-get($map, $anchor);\n  }\n}\n\n@if map-has-key($breakpoints, small) {\n  $small-up: screen;\n  $small-only: unquote('screen and #{breakpoint(small only)}');\n}\n\n@if map-has-key($breakpoints, medium) {\n  $medium-up: unquote('screen and #{breakpoint(medium)}');\n  $medium-only: unquote('screen and #{breakpoint(medium only)}');\n}\n\n@if map-has-key($breakpoints, large) {\n  $large-up: unquote('screen and #{breakpoint(large)}');\n  $large-only: unquote('screen and #{breakpoint(large only)}');\n}\n\n@if map-has-key($breakpoints, xlarge) {\n  $xlarge-up: unquote('screen and #{breakpoint(xlarge)}');\n  $xlarge-only: unquote('screen and #{breakpoint(xlarge only)}');\n}\n\n@if map-has-key($breakpoints, xxlarge) {\n  $xxlarge-up: unquote('screen and #{breakpoint(xxlarge)}');\n}\n","// Foundation for Sites by ZURB\n// foundation.zurb.com\n// Licensed under MIT Open Source\n\n////\n/// @group functions\n////\n\n/// Creates an inner box-shadow for only one side\n/// \n/// @param {Keyword} $side - Side the shadow is supposed to appear. Can be `top`, `left`, `right` or `bottom`.\n/// @param {Number} $size - Width for the target side.\n/// @param {Color} $color - Color of the shadow.\n@mixin inner-side-shadow(\n  $side: bottom,\n  $size: 20px,\n  $color: rgba($black, 0.25)\n) {\n\n  $helper: round($size * 0.65);\n\n  @if ($side == top) {\n    box-shadow: inset 0 $helper $size (-1)*$helper $color;\n  } @else if ($side == left) {\n    box-shadow: inset $helper 0 $size (-1)*$helper $color;\n  } @else if ($side == right) {\n    box-shadow: inset (-1)*$helper 0 $size (-1)*$helper $color;\n  } @else if ($side == bottom) {\n    box-shadow: inset 0 (-1)*$helper $size (-1)*$helper $color;\n  }\n}\n\n/// Creates a CSS triangle, which can be used for dropdown arrows, dropdown pips, and more. Use this mixin inside a `&::before` or `&::after` selector, to attach the triangle to an existing element.\n///\n/// @param {Number} $triangle-size - Width of the triangle.\n/// @param {Color} $triangle-color - Color of the triangle.\n/// @param {Keyword} $triangle-direction - Direction the triangle points. Can be `up`, `right`, `down`, or `left`.\n@mixin css-triangle(\n  $triangle-size,\n  $triangle-color,\n  $triangle-direction\n) {\n  display: block;\n  width: 0;\n  height: 0;\n\n  border: inset $triangle-size;\n\n  content: '';\n\n  @if ($triangle-direction == down) {\n    border-bottom-width: 0;\n    border-top-style: solid;\n    border-color: $triangle-color transparent transparent;\n  }\n  @if ($triangle-direction == up) {\n    border-top-width: 0;\n    border-bottom-style: solid;\n    border-color: transparent transparent $triangle-color;\n  }\n  @if ($triangle-direction == right) {\n    border-right-width: 0;\n    border-left-style: solid;\n    border-color: transparent transparent transparent $triangle-color;\n  }\n  @if ($triangle-direction == left) {\n    border-left-width: 0;\n    border-right-style: solid;\n    border-color: transparent $triangle-color transparent transparent;\n  }\n}\n\n/// Creates a menu icon with a set width, height, number of bars, and colors. The mixin uses the height of the icon and the weight of the bars to determine spacing. <div class=\"docs-example-burger\"></div>\n///\n/// @param {Color} $color [$black] - Color to use for the icon.\n/// @param {Color} $color-hover [$dark-gray] - Color to use when the icon is hovered over.\n/// @param {Number} $width [20px] - Width of the icon.\n/// @param {Number} $height [16px] - Height of the icon.\n/// @param {Number} $weight [2px] - Height of individual bars in the icon.\n/// @param {Number} $bars [3] - Number of bars in the icon.\n@mixin hamburger(\n  $color: $black,\n  $color-hover: $dark-gray,\n  $width: 20px,\n  $height: 16px,\n  $weight: 2px,\n  $bars: 3\n) {\n  // box-shadow CSS output\n  $shadow: ();\n  $hover-shadow: ();\n\n  // Spacing between bars is calculated based on the total height of the icon and the weight of each bar\n  $spacing: ($height - ($weight * $bars)) / ($bars - 1);\n\n  @if unit($spacing) == 'px' {\n    $spacing: floor($spacing);\n  }\n\n  @for $i from 2 through $bars {\n    $offset: ($weight + $spacing) * ($i - 1);\n    $shadow: append($shadow, 0 $offset 0 $color, comma);\n  }\n\n  // Icon container\n  position: relative;\n  display: inline-block;\n  vertical-align: middle;\n  width: $width;\n  height: $height;\n  cursor: pointer;\n\n  // Icon bars\n  &::after {\n    position: absolute;\n    top: 0;\n    left: 0;\n\n    display: block;\n    width: 100%;\n    height: $weight;\n\n    background: $color;\n    box-shadow: $shadow;\n\n    content: '';\n  }\n\n  // Hover state\n  @if $color-hover {\n    // Generate CSS\n    @for $i from 2 through $bars {\n      $offset: ($weight + $spacing) * ($i - 1);\n      $hover-shadow: append($hover-shadow, 0 $offset 0 $color-hover, comma);\n    }\n\n    &:hover::after {\n      background: $color-hover;\n      box-shadow: $hover-shadow;\n    }\n  }\n}\n\n/// Adds a downward-facing triangle as a background image to an element. The image is formatted as an SVG, making it easy to change the color. Because Internet Explorer doesn't support encoded SVGs as background images, a PNG fallback is also included.\n/// There are two PNG fallbacks: a black triangle and a white triangle. The one used depends on the lightness of the input color.\n///\n/// @param {Color} $color [$black] - Color to use for the triangle.\n@mixin background-triangle($color: $black) {\n  $rgb: 'rgb%28#{round(red($color))}, #{round(green($color))}, #{round(blue($color))}%29';\n\n  background-image: url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' width='32' height='24' viewBox='0 0 32 24'><polygon points='0,0 32,0 16,24' style='fill: #{$rgb}'></polygon></svg>\");\n\n  @media screen and (min-width:0\\0) {\n    @if lightness($color) < 60% {\n      // White triangle\n      background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAYCAYAAACbU/80AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAIpJREFUeNrEkckNgDAMBBfRkEt0ObRBBdsGXUDgmQfK4XhH2m8czQAAy27R3tsw4Qfe2x8uOO6oYLb6GlOor3GF+swURAOmUJ+RwtEJs9WvTGEYxBXqI1MQAZhCfUQKRzDMVj+TwrAIV6jvSUEkYAr1LSkcyTBb/V+KYfX7xAeusq3sLDtGH3kEGACPWIflNZfhRQAAAABJRU5ErkJggg==');\n    }\n    @else {\n      // Black triangle\n      background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAYCAYAAACbU/80AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAMBJREFUeNrEllsOhCAMRVszC9IlzU7KCmVHTJsoMWYMUtpyv9BgbuXQB5ZSdgBYYY4ycgBivk8KYFsQMfMiTTBP4o3nUzCKzOabLJbLy2/g31evGkAginR4/ZegKH5qX3bJCscA3t0x3kgO5tQFyhhFf50xRqFLbyMUNJQzgyjGS/wgCpvKqkRBpuWrE4V9d+1E4dPUXqIg107SQOE/2DRQxMwTDygIInVDET9T3lCoj/6j/VCmGjZOl2lKpZ8AAwDQP7zIimDGFQAAAABJRU5ErkJggg==');\n    }\n  }\n}\n\n/// Applies the micro clearfix hack popularized by Nicolas Gallagher. Include this mixin on a container if its children are all floated, to give the container a proper height.\n/// The clearfix is augmented with specific styles to prevent borders in flexbox environments\n/// @link http://nicolasgallagher.com/micro-clearfix-hack/ Micro Clearfix Hack\n/// @link http://danisadesigner.com/blog/flexbox-clear-fix-pseudo-elements/ Flexbox fix\n@mixin clearfix {\n  &::before,\n  &::after {\n    display: table;\n    content: ' ';\n\n    @if $global-flexbox {\n      flex-basis: 0;\n      order: 1;\n    }\n  }\n\n  &::after {\n    clear: both;\n  }\n}\n\n/// Adds CSS for a \"quantity query\" selector that automatically sizes elements based on how many there are inside a container.\n/// @link http://alistapart.com/article/quantity-queries-for-css Quantity Queries for CSS\n///\n/// @param {Number} $max - Maximum number of items to detect. The higher this number is, the more CSS that's required to cover each number of items.\n/// @param {Keyword} $elem [li] - Tag to use for sibling selectors.\n@mixin auto-width($max, $elem: li) {\n  @for $i from 2 through $max {\n    &:nth-last-child(#{$i}):first-child,\n    &:nth-last-child(#{$i}):first-child ~ #{$elem} {\n      width: percentage(1 / $i);\n    }\n  }\n}\n\n/// Removes the focus ring around an element when a mouse input is detected.\n@mixin disable-mouse-outline {\n  [data-whatinput='mouse'] & {\n    outline: 0;\n  }\n}\n\n/// Makes an element visually hidden, but still accessible to keyboards and assistive devices.\n/// @link http://snook.ca/archives/html_and_css/hiding-content-for-accessibility Hiding Content for Accessibility\n/// @link http://hugogiraudel.com/2016/10/13/css-hide-and-seek/\n@mixin element-invisible {\n  position: absolute !important;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  overflow: hidden;\n  clip: rect(0,0,0,0);\n  white-space: nowrap;\n  clip-path: inset(50%);\n  border: 0;\n}\n\n/// Reverses the CSS output created by the `element-invisible()` mixin.\n@mixin element-invisible-off {\n  position: static !important;\n  width: auto;\n  height: auto;\n  overflow: visible;\n  clip: auto;\n  white-space: normal;\n  clip-path: none;\n}\n\n/// Vertically centers the element inside of its first non-static parent,\n/// @link http://www.sitepoint.com/centering-with-sass/ Centering With Sass\n@mixin vertical-center {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n}\n\n/// Horizontally centers the element inside of its first non-static parent,\n/// @link http://www.sitepoint.com/centering-with-sass/ Centering With Sass\n@mixin horizontal-center {\n  position: absolute;\n  left: 50%;\n  transform: translateX(-50%);\n}\n\n/// Absolutely centers the element inside of its first non-static parent,\n/// @link http://www.sitepoint.com/centering-with-sass/ Centering With Sass\n@mixin absolute-center {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n\n/// Iterates through breakpoints defined in `$breakpoint-classes` and prints the CSS inside the mixin at each breakpoint's media query. Use this with the grid, or any other component that has responsive classes.\n///\n/// @param {Boolean} $small [true] - If `false`, the mixin will skip the `small` breakpoint. Use this with components that don't prefix classes with `small-`, only `medium-` and up.\n/// @param {Boolean} $auto-insert-breakpoints [true] - If `false`, the mixin will iterate over breakpoints without doing the media query itself. Useful for more complex media query generation as in the margin grid.\n@mixin -zf-each-breakpoint($small: true, $auto-insert-breakpoints: true) {\n  $list: $breakpoint-classes;\n\n  @if not $small {\n    $list: sl-remove($list, $-zf-zero-breakpoint);\n  }\n\n  @each $name in $list {\n    $-zf-size: $name !global;\n\n    @if $auto-insert-breakpoints {\n      @include breakpoint($name) {\n        @content;\n      }\n    }\n    @else {\n      @content;\n    }\n  }\n}\n\n/// Generate the `@content` passed to the mixin with a value `$-zf-bp-value` related to a breakpoint, depending on the `$name` parameter:\n/// - For a single value, `$-zf-bp-value` is this value.\n/// - For a breakpoint name, `$-zf-bp-value` is the corresponding breakpoint value in `$map`.\n/// - For \"auto\", `$-zf-bp-value` is the corresponding breakpoint value in `$map` and is passed to `@content`, which is made responsive for each breakpoint of `$map`.\n/// @param {Number|Array|Keyword} $name [auto] - Single value, breakpoint name, or list of breakpoint names to use. \"auto\" by default.\n/// @param {Number|Map} $map - Map of breakpoints and values or single value to use.\n@mixin -zf-breakpoint-value(\n  $name: auto,\n  $map: null\n) {\n  @if $name == auto and type-of($map) == 'map' {\n    // \"auto\"\n    @each $k, $v in $map {\n      @include breakpoint($k) {\n        @include -zf-breakpoint-value($v, $map) {\n          @content;\n        }\n      }\n    }\n  }\n  @else {\n    // breakpoint name\n    @if type-of($name) == 'string' {\n      $name: -zf-get-bp-val($map, $name);\n    }\n\n    // breakpoint value\n    $-zf-bp-value: $name !global;\n    @content;\n  }\n}\n","// Global base styles\n//\n//\n//\n\n/** **************\n * Basic styles\n */\nhtml {\n  box-sizing: border-box;\n}\n\n*,\n*:before,\n*:after {\n  box-sizing: inherit;\n}\n\n\nbody {\n  background-color: $global-body-background;\n  font-family: sans-serif;\n  font-size: 100%;\n  line-height: 1.5;\n  margin: 0;\n  overflow-x: hidden;\n  padding: 0;\n  -webkit-text-size-adjust: none;\n  -webkit-font-smoothing: antialiased;\n  width: 100%;\n\n  /**\n   * Add breakpoint values to <body> and parse them\n   * to js function (breakpoints.js).\n   *\n   * Source: https://www.lullabot.com/blog/article/importing-css-breakpoints-javascript\n   */\n  &:before {\n    content: 'small';\n    display: none;\n\n    @include breakpoint(medium) {\n      content: 'medium';\n    }\n\n    @include breakpoint(large) {\n      content: 'large';\n    }\n\n    @include breakpoint(xlarge) {\n      content: 'xlarge';\n    }\n\n    @include breakpoint(xxlarge) {\n      content: 'xxlarge';\n    }\n\n    @include breakpoint(xxxlarge) {\n      content: 'xxxxlarge';\n    }\n  }\n\n  &.overflow-hidden {\n    overflow: scroll;\n    overflow-x: hidden;\n    overflow-y: auto;\n  }\n}\n\n.fonts--loaded body {\n  font-family: font(base, 'body');\n}\n\n\n\n\n/** ***********\n * Text selection\n */\n::-moz-selection {\n  background: palette(brand, 'yuma');\n  color: palette(ui, 'black');\n  text-shadow: none;\n}\n\n::selection {\n  background: palette(brand, 'yuma');\n  color: palette(ui, 'black');\n  text-shadow: none;\n}\n\n\n\n\n\n\n/** ***********\n * Palceholder styles\n */\n::-webkit-input-placeholder { /* Chrome/Opera/Safari */\n  @include u-input-placeholder;\n}\n\n::-moz-placeholder { /* Firefox 19+ */\n  @include u-input-placeholder;\n}\n\n:-ms-input-placeholder { /* IE 10+ */\n  @include u-input-placeholder;\n}\n\n:-moz-placeholder { /* Firefox 18- */\n  @include u-input-placeholder;\n}\n\n\n\n\n\n\n\n\n/** ***********\n * Links\n */\na:not(img) {\n  color: palette(ui, 'black');\n  text-decoration: none;\n  transition: $global-transition;\n}\n\n\n\n\n\n\n\n/** ***********\n * Figure reset\n */\nfigure {\n  margin: 0;\n}\n\nimg {\n  max-width: 100%;\n  height: auto;\n  -ms-interpolation-mode: bicubic;\n}\n\n\n\n\n\n\n\n\n\n/** ***********\n * Sticky footer\n */\n.global-wrapper {\n  display: flex;\n  flex-direction: column;\n  min-height: 100vh;\n  height: 100%;\n}\n\n\n.global-main {\n  flex: 1 0 auto;\n\n  &:after {\n    content: '\\00a0'; /* &nbsp; */\n    display: block;\n    height: 0;\n    visibility: hidden;\n  }\n}\n"]}